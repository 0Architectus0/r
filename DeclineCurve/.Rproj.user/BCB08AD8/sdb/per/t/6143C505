{
    "contents" : "library(\"stringi\", lib.loc = \"/Library/Frameworks/R.framework/Versions/3.2/Resources/library\")\nlibrary(\"stringr\", lib.loc = \"/Library/Frameworks/R.framework/Versions/3.2/Resources/library\")\nlibrary(\"aRpsDCA\", lib.loc = \"/Library/Frameworks/R.framework/Versions/3.2/Resources/library\")\n\n# Test Vars ---------------------------------------------------------------\nresultdf <- read.csv(\"/Users/Vincent/Library/Mobile Documents/com~apple~CloudDocs/DEV/R/DeclineCurve/data/MonthlyProductionData v0.1.csv\", encoding=\"UTF-8\")\nresultdf$API <- format(resultdf$API, scientific = F)\nresultdf <- data.frame(list(as.character(resultdf$API), resultdf$CalcMonthInProd, resultdf$CalcGas))\n\n# Prod --------------------------------------------------------------------\n#dataList <- list(inpVal1, inpVal2, inpVal3)\n#resultdf <- data.frame(dataList)\n\n#TEST ---------------------------------------------------------------------\ncolnames(resultdf) <- c(\"API\", \"CalcMonth\", \"CalcGas\")\n\n#why aggregate here? should only be 1 calcgas per month per api\ndfAgg1 <- aggregate(resultdf$CalcGas, by=list(resultdf$API, resultdf$CalcMonth), FUN=sum)\ncolnames(dfAgg1) <- c(\"API\", \"CalcMonth\", \"CalcGas\")\n\ndfAggMean <- aggregate(resultdf$CalcGas, by=list(resultdf$API, resultdf$CalcMonth), FUN=mean)\ncolnames(dfAggMean) <- c(\"API\", \"CalcMonth\", \"CalcGas\")\n\n# Build year 1 max value.\ndfYr1 <- subset(dfAgg1, CalcMonth < 13)\ncolnames(dfYr1) <- c(\"API\", \"CalcMonth\", \"CalcGas\")\n\ndfYr1Max <- data.frame()\ndfYr1Max <- rbind(dfYr1Max, aggregate(dfYr1$CalcGas, by=list(dfYr1$API), FUN=max))\ncolnames(dfYr1Max) <- c(\"API\", \"CalcGasYr1\") \n\n# Build year 2 max value\ndfYr2 <- subset(dfAgg1, CalcMonth > 12)\ncolnames(dfYr2) <- c(\"API\", \"CalcMonth\", \"CalcGas\")\n\ndfYr2Max <- aggregate(dfYr2$CalcGas, by=list(dfYr2$API), FUN=max)\ncolnames(dfYr2Max) <- c(\"API\", \"CalcGasYr2\")\n\n#dfYr1==agg1\n#agg2==dfyr1Max\n\n#create table for EUR\nagg3 <- data.frame()\nwellEUR <- data.frame(character(), character(), numeric(), character())\nprobAPI <- data.frame()\n\n#populate EUR table\nfor(i in 1:nrow(dfYr1Max)) {\n  agg3 <- subset(dfAggMean, dfYr1Max[i,]$API == API)\n  colnames(agg3) <- c(\"API\", \"CalcMonth\", \"CalcGas\") \n  \n  \n  #function to handle prob API rows\n  handleProbAPI <- function(x) {\n    probRow <- data.frame(format(agg3$API, scientific = FALSE), length(agg3$CalcMonth))\n    probAPI <- rbind(probAPI, probRow)\n  }\n    \n  # Get best fit. \n  #handle API's with less than three wells\n  if(length(agg3$CalcMonth)<3){\n    \n    #dl <- list(as.character(format(agg3$API, scientific = FALSE)), \"not valid\", NULL, as.character(length(agg3$CalcMonth)))\n    wellEURRow <- data.frame(as.character(format(agg3$API, scientific = FALSE)), \"not valid\", 0, as.character(length(agg3$CalcMonth)))\n    colnames(wellEURRow) <- c(\"API\", \"hyp2expFitVal\", \"EUR\", \"CountProdMonths\")\n    colnames(wellEUR) <- colnames(wellEURRow)\n    wellEUR <- rbind(wellEUR, wellEURRow)\n    \n    next\n  }\n  \n  #reset var\n  hyp2expFitVal <- list( \"Not Valid\", NULL )\n  \n  fitme.hyp2exp.t <- agg3[[2]]\n  fitme.hyp2exp.q <- agg3[[3]]\n  try( hyp2expFitVal <- best.hyp2exp( fitme.hyp2exp.q, fitme.hyp2exp.t ))#,  finally = hyp2expFitVal <-ist( \"Not\", NULL ))\n  #e <- simpleError(\"test error\")\n  \n  commaLoc1 <- regexpr(\",\",toString(hyp2expFitVal[1]))[1] + 5  \n  commaLoc2 <- regexpr(\",\",substr(toString(hyp2expFitVal[1]), commaLoc1 + 1, 100000))[1] + commaLoc1 + 4\n  commaLoc3 <- regexpr(\",\",substr(toString(hyp2expFitVal[1]), commaLoc2 + 1, 100000))[1] + commaLoc2 + 5\n  endOfLine <- regexpr(\")\",toString(hyp2expFitVal[1]))[1]  \n  \n  qi <- as.numeric( substr( toString( hyp2expFitVal[1] ), 11, commaLoc1 - 6 ) )\n  di <- as.numeric( substr( toString( hyp2expFitVal[1] ), commaLoc1 + 1, commaLoc2 - 5 ) )\n  bfactor <- as.numeric( substr( toString( hyp2expFitVal[1] ), commaLoc2 + 1, commaLoc3 - 6 ) )\n  df <- as.numeric( substr( toString( hyp2expFitVal [1] ), commaLoc3 + 1, endOfLine - 1 ) ) \n  \n  try( decline <- arps.decline( qi, di, bfactor, df ) )\n  EUR <-0\n  try( EUR <- arps.eur( decline, 24 ) ) \n  dl <- list(as.character(dfYr1Max[i,]$API), toString(hyp2expFitVal[1]), EUR[1], toString(length(agg3$CalcMonth)))\n  wellEURRow <- data.frame(dl)\n  colnames(wellEURRow) <- c(\"API\", \"hyp2expFitVal\", \"EUR\", \"CountProdMonths\")\n  colnames(wellEUR) <- c(\"API\", \"hyp2expFitVal\", \"EUR\", \"CountProdMonths\")\n  wellEUR <- rbind(wellEUR, wellEURRow)\n} \n\n# Merge year one and two together.\ndfWellMaxTable <- merge(x=dfYr1Max, y=dfYr2Max, \"API\")\n# Merge Max and EUR tables\ndfWellAnalysisTable <- merge(x=dfWellMaxTable, y=wellEUR, \"API\")\n\ncolnames(dfWellAnalysisTable) <- c(\"API\", \"Yr1MaxCalcGas\", \"Yr2MaxCalcGas\", \"hyp2expFitVal\", \"EUR\", \"CountProdMonths\")",
    "created" : 1449150984971.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2131748442",
    "id" : "6143C505",
    "lastKnownWriteTime" : 1448507776,
    "path" : "C:/Users/oke14406/iCloudDrive/DEV/R/DeclineCurve/BuildWellAnalysisTable_v1.r",
    "project_path" : "BuildWellAnalysisTable_v1.r",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_source"
}